{"pageProps":{"article":{"blog_id":"2e0c2a54-4f19-4a01-ba8d-81ac27a95cd3","title":"Complete Guide to Ansible: Modern Server Configuration Automation","short_description":"In today's infrastructure management landscape, efficiency, speed, and consistency are essential. One of the most popular and flexible configuration automation tools available today is Ansible. This article explores the urgency of using Ansible, its definition, how it works, and provides a practical tutorial to get you started quickly.","description":"<p>In today's infrastructure management landscape, efficiency, speed, and consistency are essential. One of the most popular and flexible configuration automation tools available today is <strong>Ansible</strong>. This article explores the urgency of using Ansible, its definition, how it works, and provides a practical tutorial to get you started quickly.</p><h2><strong>Why is Ansible Needed?</strong></h2><p>When managing multiple servers, manual configuration such as logging in one by one and executing scripts becomes tedious, inconsistent, and error-prone. Tasks like:</p><p>- Installing software on 10+ servers</p><p>- Copying configuration files</p><p>- Ensuring environments are identical</p><p>...are exhausting when done manually.</p><p><strong>The solution: Automation.</strong> And that’s where <strong>Ansible</strong> steps in as a lightweight, simple tool that doesn’t require any agent installed on the servers.</p><h2><strong>What is Ansible?</strong></h2><p><strong>Ansible</strong> is an open-source IT automation engine developed by Red Hat. It automates cloud provisioning, configuration management, application deployment, and many other IT needs.</p><p>It enables you to write simple, human-readable YAML scripts called <strong>playbooks</strong> to automate the setup and maintenance of systems, reducing the need for repetitive manual work.</p><h3><strong>Key Benefits of Ansible:</strong></h3><p><strong>1. Agentless</strong>: No need to install software on managed nodes. It uses SSH by default.</p><p><strong>2. Simple syntax</strong>: Written in YAML (Yet Another Markup Language), playbooks are easy to write and understand.</p><p><strong>3. Idempotency</strong>: Re-running the same playbook won't change anything if the system is already in the desired state.</p><p><strong>4. Modular</strong>: Use modules to perform tasks like installing packages, copying files, restarting services, etc.</p><h2><strong>How Does Ansible Work?</strong></h2><p>Ansible follows a simple architecture:</p><p><strong>1. Control Node</strong>: This is the machine where Ansible is installed and from which you run commands (typically your local machine or a dedicated automation server).</p><p><strong>2. Managed Nodes</strong>: These are the target machines that Ansible configures. They don’t require any agent—just SSH access.</p><p><strong>3. Inventory File</strong>: A file that defines which hosts Ansible will manage, grouped for specific tasks.</p><p><strong>4. Playbooks</strong>: YAML files that define tasks to execute on target hosts.</p><p><strong>5. Modules</strong>: Ansible provides hundreds of built-in modules that handle tasks like package management, file manipulation, and service management.</p><h3><strong>Execution Flow:</strong></h3><p>- You run a command like <strong><em>ansible-playbook -i inventory playbook.yml</em></strong>&nbsp;from the control node.</p><p>- Ansible reads the <strong>inventory</strong> to determine target hosts.</p><p>- It connects to each host over <strong>SSH</strong> using the user defined in the inventory.</p><p>- It then runs the tasks described in the <strong>playbook</strong> using appropriate <strong>modules</strong>.</p><p>- Output is streamed back, showing success, changes, or errors.</p><p>This architecture eliminates the need for complex client-server setups and makes Ansible ideal for simple to moderately complex environments.</p><h2><strong>Hands-On Ansible Tutorial</strong></h2><h3><strong>1. Install Ansible (on your local machine)</strong></h3><p><strong>Ubuntu/Debian</strong></p><div><pre><code>sudo apt update\nsudo apt install ansible -y\n</code></pre></div><p><strong>macOS (Homebrew)</strong></p><div><pre><code>brew install ansible\n</code></pre></div><p>After installation, confirm the ansible and ansible-playbook commands are available:</p><div><pre><code>which ansible\nwhich ansible-playbook\n</code></pre></div><p>Both should return a valid path if installed correctly.</p><h3><strong>2. Create an SSH Key for Passwordless Login</strong></h3><p>Run the following on your local machine:</p><div><pre><code>ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n</code></pre></div><p>- Press ENTER to use the default location (~/.ssh/id_rsa)</p><p>- Leave the passphrase empty for fully automated access</p><p><strong>Copy the public key to the target server:</strong></p><div><pre><code>ssh-copy-id user@&lt;TARGET_IP&gt;\n</code></pre></div><p>Example:</p><div><pre><code>ssh-copy-id vagrant@192.168.56.10\n</code></pre></div><p><strong>If </strong>ssh-copy-id<strong> is not available, do it manually:</strong></p><div><pre><code>cat ~/.ssh/id_rsa.pub | ssh user@&lt;TARGET_IP&gt; 'mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys'\n</code></pre></div><p>Test the connection:</p><div><pre><code>ssh user@&lt;TARGET_IP&gt;\n</code></pre></div><p>If you connect without being prompted for a password, it’s working.</p><h3><strong>3. Set Up Your Ansible Project Structure</strong></h3><p>Organize your Ansible files in a dedicated project folder:</p><div><pre><code>mkdir my-ansible-project\ncd my-ansible-project\n</code></pre></div><p>Inside this folder:</p><div><pre><code>my-ansible-project/\n├── inventory       # List of target servers\n└── playbook.yml    # The automation instructions (YAML)\n</code></pre></div><p>File:&nbsp;inventory</p><div><pre><code>[web]\n192.168.56.10 ansible_user=vagrant\n</code></pre></div><p>The inventory file defines the groups and IP addresses of your target servers. The ansible_user specifies which user to SSH into the server as.</p><p>Note: The inventory file does not require any file extension (like .ini or .yaml). You can name it anything (e.g., myhosts, prod_inventory). What matters is that you provide the filename when using the -i option with ansible-playbook.</p><h4>File: playbook.yml</h4><div><pre><code>- name: Install nginx on web server\n  hosts: web\n  become: yes\n  tasks:\n    - name: Update apt cache\n      apt:\n        update_cache: yes\n\n    - name: Install nginx\n      apt:\n        name: nginx\n        state: present\n</code></pre></div><p>This playbook tells Ansible to connect to all servers in the web group and perform the listed tasks with root privileges (via become: yes).</p><h3><strong>4. Execute the Playbook</strong></h3><p>To run the playbook, use the ansible-playbook command:</p><div><pre><code>ansible-playbook -i inventory playbook.yml\n</code></pre></div><p>Explanation:</p><p>- i inventory: Specifies the inventory file (list of target hosts)</p><p>- playbook.yml: The YAML file with instructions to execute</p><p>If successful, you'll see task-by-task output. The target server will now have NGINX installed.</p><p>Verify by visiting:</p><div><pre><code>http://192.168.56.10\n</code></pre></div><h2><strong>Ansible in CI/CD Pipelines (e.g., Jenkins Integration)</strong></h2><p>Once you're comfortable running Ansible manually, it becomes even more powerful when integrated into automated CI/CD workflows.</p><p>With <strong>Jenkins</strong>, for example, you can:</p><p>1. Trigger Ansible playbook execution after code is pushed to Git</p><p>2. Use Jenkins pipelines to call Ansible commands for deployment</p><p>3. Automate full delivery pipelines — from code change to deployment</p><p><strong>Sample Jenkins pipeline step:</strong></p><div><pre><code>sh 'ansible-playbook -i inventory deploy.yml'\n</code></pre></div><p>You can also use ansible-vault in combination to protect secrets and credentials in your playbooks.</p><p>This approach combines the strengths of Jenkins (pipeline orchestration) and Ansible (server configuration) into a robust, automated infrastructure management workflow.</p><h2><strong>Conclusion</strong></h2><p>Ansible makes server configuration fast, consistent, and repeatable. With simple YAML files and secure SSH-based execution, you can manage tens or hundreds of servers efficiently. This is just the beginning — advanced topics like roles, handlers, variables, and CI/CD integration offer even more power. Start automating your infrastructure today with Ansible!</p>","timestamp":"Sunday, June 15, 2025 at 6:03:22 PM GMT+8","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1749981290145_ansible%20background.png","image_alt":"Ansible Background Image","slug":"Complete-Guide-to-Ansible-Modern-Server-Configuration-Automation","index":"d4735e3a265e1","tags":["CI/CD","DevOps","Automation"]},"recommendedPosts":[{"blog_id":"8d0028d2-2f56-4466-baab-f36030547946","title":"From Kubernetes Overload to Observability: How the Sidecar Pattern in Service Mesh Saves the Day","short_description":"Kubernetes, a popular tool, helps manage these pieces by running them in containers and ensuring they’re available and scalable. But as your application grows, Kubernetes alone can’t handle everything. Let’s break this down and see how the sidecar pattern in a service mesh comes to the rescue, making your system easier to monitor, secure, and manage.","timestamp":"2025-06-07 13:17:06","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1749300528520_sidecar%20pattern%20background.png","image_alt":"Sidecar pattern Background","slug":"From-Kubernetes-Overload-to-Observability-How-the-Sidecar-Pattern-in-Service-Mesh-Saves-the-Day","index":"d4735e3a265e1","tags":["Deployment","Distributed Systems","Microservices","DevOps"]},{"blog_id":"109a123a-02ae-4b9f-96a9-785428eef2fa","title":"Jenkins Unleashed: Transforming Your CI/CD Workflow for Lightning-Fast Delivery","short_description":"In the fast-paced world of modern software development, delivering high-quality applications quickly is no longer optional—it's essential. This is where Jenkins steps in as a game-changer. Imagine having a virtual assistant that tirelessly builds, tests, and deploys your code, ensuring every update you make reaches production seamlessly.","timestamp":"2025-01-06 04:32:13","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fjenkins_background.png?alt=media&token=8d8f21c7-f6bd-4157-8343-12090e88d13a","image_alt":"Jenkins Intro image","slug":"Jenkins-Unleashed-Transforming-Your-CICD-Workflow-for-Lightning-Fast-Delivery","index":"6b86b273ff34f","tags":["CI/CD","System Design"]}]},"__N_SSG":true}
{"pageProps":{"article":{"blog_id":"52acda91-39c3-4ea5-8ba0-ad616298fad1","title":"Understanding Event Sourcing with a Digital Wallet Case Study","short_description":"Event Sourcing is an architectural pattern where every change to an application's state is stored as an immutable event, rather than just storing the final state. This fundamentally changes how systems record, reconstruct, and interact with data over time.","description":"<p>Event Sourcing is an architectural pattern where <strong>every change to an application's state is stored as an immutable event</strong>, rather than just storing the final state. This fundamentally changes how systems record, reconstruct, and interact with data over time.</p><p>In this blog, we’ll explore what Event Sourcing is, why it’s important, when to use it, its benefits and trade-offs, and then bring it all together with a concrete case study: a digital wallet application.</p><h2><strong>What is Event Sourcing?</strong></h2><p>Traditional systems tend to persist only the latest version of data. For example, in a user table, we store a user’s current name, email, and preferences. If a user changes their name three times, we typically only keep the last one, unless we explicitly log historical records elsewhere.</p><p><strong>Event Sourcing flips this approach.</strong> Instead of persisting only the current state, we persist a log of all the events that led to that state. These events are stored in an append-only event store, forming a complete chronological sequence of what happened in the system.</p><h3><strong>Key Concepts:</strong></h3><p>- <strong>Event</strong>: A record of something that happened in the system (e.g., `UserRegistered`, `MoneyDeposited`).</p><p>- <strong>Event </strong>Store: A specialized database or log that stores events in the order they occurred.</p><p>- <strong>Rehydration / Replay</strong>: The process of rebuilding the current state of an entity by replaying all its events from the beginning.</p><p>This approach is inspired by transaction logs in databases and event logs in distributed systems (like Apache Kafka).</p><h2><strong>Why Use Event Sourcing?</strong></h2><p>1. <strong>Complete Audit Trail</strong></p><p>Every change is recorded. You can see exactly what happened, when, and why.</p><p>2. <strong>Time Travel / Historical State</strong></p><p>You can recreate the state of the system at any point in the past. This is incredibly useful for debugging or compliance.</p><p>3. <strong>Undo/Redo Capabilities</strong></p><p>Because every change is an event, you can reverse or replay them easily, allowing powerful features like rollback or state simulation.</p><p>4. <strong>Decoupled Read and Write Models</strong></p><p>Event Sourcing pairs naturally with <strong>CQRS (Command Query Responsibility Segregation)</strong>, where write operations generate events and read models are optimized views of that data.</p><p>5. <strong>Scalability &amp; Flexibility</strong></p><p>You can project the same event stream into multiple read models tailored for different business needs.</p><h2><strong>When Should You Use Event Sourcing?</strong></h2><p>While Event Sourcing offers powerful benefits, it’s not for every application. <strong>You should consider using it when:</strong></p><p>- The domain is complex and benefits from modeling behavior explicitly (e.g., finance, logistics, healthcare).</p><p>- You require a full audit trail or regulatory compliance.</p><p>- You want to support advanced features like event replay, analytics on history, or user activity tracing.</p><p>- You’re building a system that evolves over time, and want to decouple the logic for data capture from the logic for data usage.</p><p><strong>Avoid Event Sourcing if:</strong></p><p>- Your domain is very simple and doesn’t change frequently.</p><p>- Your team is not experienced with eventual consistency or distributed systems.</p><p>- You don’t need history and are optimizing for simplicity and rapid development.</p><h2>How Event Sourcing Works: A Step-by-Step Breakdown</h2><p><strong>- Command Handling </strong>The user initiates an action (e.g., deposit money).</p><p>- The system validates the command (e.g., user exists, sufficient permissions).</p><p>- If valid, an event (e.g., <strong>MoneyDeposited</strong>) is created.</p><p><strong>- Event Persistence </strong>The event is saved to the event store, which is append-only and immutable.</p><p><strong>- Event Replay (Rehydration) </strong>To rebuild the current state of a user’s wallet, all related events are replayed in order.</p><p><strong>- Projection to Read Model </strong>Events are consumed by handlers to update read models (e.g., current balance, transaction history).</p><h2><strong>Case Study: Digital Wallet System</strong></h2><p><strong>Features:</strong></p><p>- Users can register an account.</p><p>- Users can deposit and withdraw funds.</p><p>- Users can view their balance and transaction history.</p><p><strong>Event Types:</strong></p><div><pre><code>{\n&nbsp; \"type\": \"UserCreated\",\n&nbsp; \"userId\": \"1\",\n&nbsp; \"name\": \"Ari\"\n}\n{\n&nbsp; \"type\": \"MoneyDeposited\",\n&nbsp; \"userId\": \"1\",\n&nbsp; \"amount\": 100\n}\n{\n&nbsp; \"type\": \"MoneyWithdrawn\",\n&nbsp; \"userId\": \"1\",\n&nbsp; \"amount\": 30\n}\n</code></pre></div><p>Each event is stored chronologically in the event store.</p><p><strong>Rebuilding State:</strong></p><div><pre><code>let balance = 0;\nfor (const event of userEvents) {\n&nbsp; if (event.type === \"MoneyDeposited\") balance += event.amount;\n&nbsp; if (event.type === \"MoneyWithdrawn\") balance -= event.amount;\n}\n</code></pre></div><h3><strong>Optimization: Read Model (/balance)</strong></h3><p>Replaying all events every time a user requests their balance is inefficient, especially when the number of events becomes large. To solve this, we build <strong>read models</strong>, which are materialized views or projections that are updated in response to events.</p><h4>What is a Read Model?</h4><p>A read model is a denormalized and query-optimized view of your data, often stored in a different storage engine (e.g., SQL, MongoDB, Redis).</p><p>For example:</p><p>- A <strong>/balance </strong>endpoint reads from a `balance_projection` table that is updated every time a `MoneyDeposited` or `MoneyWithdrawn` event occurs.</p><p>- A <strong> /transactions </strong>endpoint uses a `transaction_log` projection that simply appends new entries.</p><h4><strong>Read Model Optimization Techniques:</strong></h4><p><strong>1. Precompute Aggregates</strong>: For values like balance, update them incrementally as new events arrive, instead of recomputing from scratch.</p><p><strong>2. Store Snapshots</strong>: Save intermediate state snapshots periodically to reduce the number of events needed during rehydration.</p><p><strong>3. Async Event Handlers</strong>: Use background workers or message queues to process events and update read models asynchronously, ensuring fast writes and eventual consistency.</p><p><strong>4. Polyglot Storage</strong>: Use the best storage type per read model: Redis for caching, PostgreSQL for reporting, Elasticsearch for search.</p><p><strong>5. Sharding/Partitioning</strong>: Distribute projections across shards if the volume grows significantly.</p><p>These optimizations allow your event-sourced system to handle read-heavy workloads efficiently without sacrificing the advantages of a full event history.</p><h2><strong>Benefits Recap</strong></h2><p>Event Sourcing provides several strategic benefits:</p><p>- It enables a complete audit trail, recording every user action in the system.</p><p>- Undo and redo functionality become feasible, as the system can reconstruct any prior state from its event history.</p><p>- Debugging and analytics are easier because you can replay and analyze event flows.</p><p>- Scalable read models can be tailored for different use cases, improving performance and flexibility.</p><p>- The architecture encourages decoupling, where each component reacts to events without tight integration.</p><h2><strong>Challenges and Considerations</strong></h2><p>Despite its advantages, Event Sourcing comes with certain challenges:</p><p>- Event schema evolution can become complex. To manage changes in event formats, you may need versioning, upcasting, or adapters.</p><p>- Eventual consistency requires a mental shift. Developers must understand that write and read paths may not be immediately in sync.</p><p>- Debugging across asynchronous boundaries may need custom tools to inspect and trace events effectively.</p><p>- The learning curve is steeper than traditional CRUD systems. Your team must be comfortable with asynchronous workflows and immutability.</p><h2>Tools and Libraries</h2><p>Popular tools that support Event Sourcing:</p><p><strong>- Event Store</strong> – purpose-built database for event sourcing.</p><p><strong>- Axon Framework (Java)</strong> – provides CQRS and event sourcing support.</p><p><strong>- Akka Persistence (Scala)</strong> – for event-sourced actors.</p><p><strong>- Kafka + Kafka Streams</strong> – can be adapted to support event sourcing.</p><p><strong>- NEventStore / Marten (C#)</strong> – .NET solutions.</p><p><strong>- TypeORM + custom event store</strong> (Node.js) – lightweight approach.</p><h2><strong>Final Thoughts</strong></h2><p>Event Sourcing is a powerful pattern for systems that need visibility into how state evolves. While it introduces complexity, the ability to replay, audit, and model system behavior over time is a compelling advantage.</p><p>If you’re building systems that handle transactions, user behavior, domain complexity, or require traceability — Event Sourcing could unlock significant long-term value.</p>","timestamp":"Tuesday, May 27, 2025 at 9:29:23 AM GMT+8","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1748307293910_event%20sourcing%20bg.jpg","image_alt":"Event Sourcing Pattern","slug":"Understanding-Event-Sourcing-with-a-Digital-Wallet-Case-Study","index":"d4735e3a265e1","tags":["Software Architecture","System Design","Event Sourcing"]},"recommendedPosts":[{"blog_id":"36855ea7-b37b-4b4c-91f1-27d90b9bde59","title":"Understanding Database Partitioning vs Sharding: Concepts, Benefits, and Challenges","short_description":"When dealing with large volumes of data, efficient database management becomes essential. Two widely used techniques to improve performance and scalability are database partitioning and database sharding. Although often confused, these approaches differ fundamentally in architecture, complexity, and suitable use cases. This article explores these differences in detail, helping you decide which fits your application best.","timestamp":"2025-05-17 09:42:15","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747474398774_partition%20vs%20sharding%20db.png","image_alt":"partition vs sharding Database","slug":"Understanding-Database-Partitioning-vs-Sharding-Concepts-Benefits-and-Challenges","index":"d4735e3a265e1","tags":["Database","Database Architecture","Software Architecture","System Design"]},{"blog_id":"675f800c-08cb-459f-aa7d-44cdc9c9c169","title":"System Design Simplified: The Trade-Off Triangle You Must Master","short_description":"Behind every well-architected system is a set of tough decisions. The CAP Theorem simplifies those decisions by showing you what you must give up to keep your system fast, correct, and resilient. Learn how to apply this in real-world architecture.","timestamp":"2025-05-13 01:58:48","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747100859417_CAP%20BG.jpg","image_alt":"CAP background","slug":"System-Design-Simplified-The-Trade-Off-Triangle-You-Must-Master","index":"d4735e3a265e1","tags":["System Design","CAP Theorem","Distributed Systems"]},{"blog_id":"5c2626c4-8a10-47f1-8c5c-b3ac2d84b69a","title":"Why Domain-Driven Design (DDD) Matters: From Chaos to Clarity in Complex Systems","short_description":"Domain-Driven Design (DDD) is a powerful approach to software development that places the business domain—not the technology—at the center of your design decisions. First introduced by Eric Evans, DDD is essential for developers and architects who want to build systems that reflect real-world complexity and change.","timestamp":"2025-05-12 04:23:04","image":"https://storage.googleapis.com/personal-blog-darmajr.appspot.com/blog-content/1747022797381_Domain-Driven-Design_cover.jpg","image_alt":"DDD Cover","slug":"Why-Domain-Driven-Design-DDD-Matters-From-Chaos-to-Clarity-in-Complex-Systems","index":"d4735e3a265e1","tags":["DDD","Software Architecture","System Design"]}]},"__N_SSG":true}